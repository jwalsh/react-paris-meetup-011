#+TITLE: React Performance Masterclass
#+SUBTITLE: React Paris Meetup #013 - WIP
#+AUTHOR: React Paris Community
#+DATE: 2025
#+OPTIONS: toc:nil num:nil reveal_single_file:t
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_THEME: blood
#+REVEAL_TRANS: zoom
#+REVEAL_PLUGINS: (highlight notes zoom)
#+REVEAL_EXTRA_CSS:
#+REVEAL_TITLE_SLIDE: <h1>%t</h1><h3>%s</h3><p>%a | %d</p>

* The Performance Mindset
:PROPERTIES:
:reveal_background: #1a0000
:END:

** Measure First, Optimize Second

#+BEGIN_QUOTE
"Premature optimization is the root of all evil"
-- Donald Knuth
#+END_QUOTE

#+ATTR_REVEAL: :frag (appear)
- Profile before you optimize
- Real user metrics > synthetic benchmarks
- Perceived performance matters more than actual
- Every optimization has a cost

** What We'll Master

#+ATTR_REVEAL: :frag (appear)
1. React DevTools Profiler deep dive
2. Identifying unnecessary re-renders
3. useMemo/useCallback: truth and myths
4. Code splitting strategies
5. Core Web Vitals optimization

* Part 1: Profiling with DevTools
:PROPERTIES:
:reveal_background: #2a0000
:END:

** React DevTools Profiler

*** Opening the Profiler

#+BEGIN_SRC text
Chrome/Firefox DevTools
    |
    +-- Components tab (tree view)
    |
    +-- Profiler tab (performance)
         |
         +-- Start recording
         +-- Perform interactions
         +-- Stop and analyze
#+END_SRC

** Understanding the Flame Graph

#+BEGIN_SRC text
Commit #1 (200ms)
+------------------------------------------+
| App (5ms)                                |
| +--------------------------------------+ |
| | Header (1ms)     | Main (180ms)      | |
| |                  | +----------------+ | |
| |                  | | ProductList    | | |
| |                  | | (150ms) [!!!]  | | |
| |                  | +----------------+ | |
| +--------------------------------------+ |
+------------------------------------------+

Yellow/Red = Slow renders
Gray = Did not render
#+END_SRC

** Key Metrics to Watch

| Metric             | What It Means                      |
|--------------------+------------------------------------|
| Render duration    | Time spent in render phase         |
| Commit duration    | Time to apply changes to DOM       |
| Renders count      | Times component re-rendered        |
| Why did this render? | Reason for re-render (props/state/context) |

** Ranked Chart View

#+BEGIN_SRC text
Sorted by render time:

1. ProductList        150ms  ████████████████████
2. ProductItem x 100   30ms  ████
3. SearchBar           15ms  ██
4. Header               1ms  |
5. Footer               1ms  |

Focus optimization on top items first!
#+END_SRC

* Part 2: Unnecessary Re-renders
:PROPERTIES:
:reveal_background: #1a0000
:END:

** The Re-render Problem

#+BEGIN_SRC jsx
function Parent() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>
        {count}
      </button>
      {/* Child re-renders every time! */}
      <ExpensiveChild />
    </div>
  );
}

function ExpensiveChild() {
  // Heavy computation here
  const result = heavyCalculation();
  return <div>{result}</div>;
}
#+END_SRC

** Solution 1: React.memo

#+BEGIN_SRC jsx
const ExpensiveChild = React.memo(function ExpensiveChild() {
  const result = heavyCalculation();
  return <div>{result}</div>;
});

// Now only re-renders if props change
#+END_SRC

But beware...

** The memo Trap

#+BEGIN_SRC jsx
function Parent() {
  const [count, setCount] = useState(0);

  // New object every render - memo breaks!
  const style = { color: 'red' };

  // New function every render - memo breaks!
  const handleClick = () => console.log('clicked');

  return (
    <MemoizedChild
      style={style}        // Always new reference
      onClick={handleClick} // Always new reference
    />
  );
}
#+END_SRC

** Solution: Stable References

#+BEGIN_SRC jsx
function Parent() {
  const [count, setCount] = useState(0);

  // Stable object reference
  const style = useMemo(() => ({ color: 'red' }), []);

  // Stable function reference
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);

  return (
    <MemoizedChild
      style={style}
      onClick={handleClick}
    />
  );
}
#+END_SRC

* Part 3: useMemo and useCallback Truth
:PROPERTIES:
:reveal_background: #2a0000
:END:

** The Myth

#+BEGIN_QUOTE
"Always use useMemo and useCallback for performance"
#+END_QUOTE

The Reality:
#+ATTR_REVEAL: :frag (appear)
- They have overhead (memory + comparison)
- Most computations are fast enough
- Only useful with memo'd children or expensive calculations

** When useMemo Actually Helps

#+BEGIN_SRC jsx
// GOOD: Expensive computation
const sortedItems = useMemo(() => {
  return items
    .filter(complexFilter)
    .sort(complexSort)
    .map(complexTransform);
}, [items]);

// GOOD: Reference for memo'd child
const config = useMemo(() => ({
  theme: 'dark',
  locale: 'fr'
}), []);

// BAD: Simple computation
const doubled = useMemo(() => count * 2, [count]);
// Just do: const doubled = count * 2;
#+END_SRC

** When useCallback Actually Helps

#+BEGIN_SRC jsx
// GOOD: Passed to memo'd child
const MemoChild = React.memo(Child);

function Parent() {
  const handleClick = useCallback(() => {
    doSomething();
  }, []);

  return <MemoChild onClick={handleClick} />;
}

// GOOD: Dependency of useEffect
const fetchData = useCallback(() => {
  // ...
}, [userId]);

useEffect(() => {
  fetchData();
}, [fetchData]);
#+END_SRC

** The Decision Framework

#+BEGIN_SRC text
Should I use useMemo/useCallback?

1. Is computation > 1ms? (Profile it!)
   -> Yes: Consider useMemo

2. Is value passed to memo'd child?
   -> Yes: Use useMemo/useCallback

3. Is function a useEffect dependency?
   -> Yes: Use useCallback

4. None of the above?
   -> Skip it, add complexity only when needed
#+END_SRC

* Part 4: Code Splitting
:PROPERTIES:
:reveal_background: #1a0000
:END:

** The Bundle Problem

#+BEGIN_SRC text
Your app bundle: 2MB

User visits homepage:
  Needs: 200KB
  Downloads: 2MB  [!!!]
  Parses: 2MB JavaScript

Time to Interactive: 8 seconds
#+END_SRC

** React.lazy + Suspense

#+BEGIN_SRC jsx
import { lazy, Suspense } from 'react';

// Split at route level
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Settings = lazy(() => import('./pages/Settings'));
const Analytics = lazy(() =>
  import('./pages/Analytics')
);

function App() {
  return (
    <Suspense fallback={<PageLoader />}>
      <Routes>
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/settings" element={<Settings />} />
        <Route path="/analytics" element={<Analytics />} />
      </Routes>
    </Suspense>
  );
}
#+END_SRC

** Strategic Splitting Points

#+BEGIN_SRC text
Split here:
  +-- Route boundaries (pages)
  +-- Modal/dialog content
  +-- Below-the-fold content
  +-- Admin-only features
  +-- Heavy libraries (charts, editors)

Don't split:
  +-- Small components
  +-- Frequently used components
  +-- Critical path components
#+END_SRC

** Named Exports with lazy

#+BEGIN_SRC jsx
// components/Charts.tsx exports multiple
export const LineChart = () => { /*...*/ };
export const BarChart = () => { /*...*/ };
export const PieChart = () => { /*...*/ };

// Lazy load specific export
const LineChart = lazy(() =>
  import('./components/Charts').then(module => ({
    default: module.LineChart
  }))
);
#+END_SRC

* Part 5: Core Web Vitals
:PROPERTIES:
:reveal_background: #2a0000
:END:

** The Three Vital Metrics

| Metric | Name                     | Target  |
|--------+--------------------------+---------|
| LCP    | Largest Contentful Paint | < 2.5s  |
| INP    | Interaction to Next Paint| < 200ms |
| CLS    | Cumulative Layout Shift  | < 0.1   |

** LCP Optimization

#+BEGIN_SRC jsx
// 1. Preload critical images
<link
  rel="preload"
  href="/hero.jpg"
  as="image"
  fetchpriority="high"
/>

// 2. Use Next.js Image with priority
import Image from 'next/image';

<Image
  src="/hero.jpg"
  priority  // Preloads the image
  fill
  sizes="100vw"
/>

// 3. Avoid lazy loading above-the-fold content
#+END_SRC

** INP Optimization

#+BEGIN_SRC jsx
// Break up long tasks
function handleClick() {
  // BAD: One long task (blocks main thread)
  processAllItems(items);

  // GOOD: Yield to browser
  for (const item of items) {
    processItem(item);
    await scheduler.yield(); // or setTimeout(0)
  }
}

// Use React concurrent features
function SearchResults({ query }) {
  const [results, setResults] = useState([]);

  const deferredQuery = useDeferredValue(query);
  // Results update without blocking input
}
#+END_SRC

** CLS Optimization

#+BEGIN_SRC jsx
// 1. Always set dimensions
<img
  src="/photo.jpg"
  width={800}
  height={600}
  alt="Photo"
/>

// 2. Reserve space for async content
<div style={{ minHeight: '200px' }}>
  <Suspense fallback={<Skeleton height={200} />}>
    <AsyncContent />
  </Suspense>
</div>

// 3. Avoid inserting content above existing
// Use transform instead of top/left for animations
#+END_SRC

* Part 6: Advanced Patterns
:PROPERTIES:
:reveal_background: #1a0000
:END:

** Virtualization for Long Lists

#+BEGIN_SRC jsx
import { useVirtualizer } from '@tanstack/react-virtual';

function VirtualList({ items }) {
  const parentRef = useRef(null);

  const virtualizer = useVirtualizer({
    count: items.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 50,
    overscan: 5
  });

  return (
    <div ref={parentRef} style={{ height: '400px', overflow: 'auto' }}>
      <div style={{ height: virtualizer.getTotalSize() }}>
        {virtualizer.getVirtualItems().map(row => (
          <div
            key={row.key}
            style={{
              position: 'absolute',
              top: row.start,
              height: row.size
            }}
          >
            {items[row.index].name}
          </div>
        ))}
      </div>
    </div>
  );
}
#+END_SRC

** Web Workers for Heavy Computation

#+BEGIN_SRC jsx
// worker.js
self.onmessage = (e) => {
  const result = heavyComputation(e.data);
  self.postMessage(result);
};

// Component
function DataProcessor({ data }) {
  const [result, setResult] = useState(null);

  useEffect(() => {
    const worker = new Worker('worker.js');
    worker.postMessage(data);
    worker.onmessage = (e) => setResult(e.data);
    return () => worker.terminate();
  }, [data]);

  return result ? <Results data={result} /> : <Loading />;
}
#+END_SRC

* Summary
:PROPERTIES:
:reveal_background: #2a0000
:END:

** Performance Checklist

#+ATTR_REVEAL: :frag (appear)
- [ ] Profile before optimizing
- [ ] Fix unnecessary re-renders first
- [ ] Use memo strategically, not everywhere
- [ ] Code split at route boundaries
- [ ] Optimize Core Web Vitals
- [ ] Virtualize long lists
- [ ] Defer non-critical work

** Resources

- [[https://react.dev/learn/render-and-commit][React: Render and Commit]]
- [[https://web.dev/vitals/][Web Vitals]]
- [[https://tanstack.com/virtual][TanStack Virtual]]
- [[https://million.dev/][Million.js - Make React Faster]]

* Questions?
:PROPERTIES:
:reveal_background: #1a0000
:END:

#+BEGIN_CENTER
Performance is a feature!

React Paris Meetup #013
#+END_CENTER
